システムプログラミング特論
演習 6 レポート
201220688 濱田一喜

演習問題 1
掲示したプログラムにおいて，main_loop() を実装し，動作の確認を行いなさい．main_loop() が生成するクライアント用のスレッドでは，EOFを待ち，EOFとなったら disconnected と表示して終了すること．

プログラム
概要
main_loop() ではクライアントからの接続を受けとると、接続情報を出力した後 respond() スレッドを起動する。
respond() スレッドは起動直後にデタッチされる。呼び出し元の main_loop() での待ち合わせは行われない。
respond() スレッドでは、EOF が入力されるまでクライアントのパケットを読みつづけ、そのままログに出力する。また、クライアントに同じ文字列を送り返す。
EOF を受けとると、コネクションを切断してスレッドは終了する。

ソースリスト
/* main.c */
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <pthread.h>

#include "logutil.h"

#define DEFAULT_SERVER_PORT 10000
#ifdef SOMAXCONN
#define LISTEN_BACKLOG SOMAXCONN
#else
#define LISTEN_BACKLOG 5
#endif

char *program_name = "sp6-server";

int
open_accepting_socket(int port)
{
  struct sockaddr_in self_addr;
  socklen_t self_addr_size;
  int sock, sockopt;

  memset(&self_addr, 0, sizeof(self_addr));
  self_addr.sin_family = AF_INET;
  self_addr.sin_addr.s_addr = INADDR_ANY;
  self_addr.sin_port = htons(port);
  self_addr_size = sizeof(self_addr);
  sock = socket(PF_INET, SOCK_STREAM, 0);
  if (sock < 0)
    logutil_fatal("accepting socket: %d", errno);
  sockopt = 1;
  if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
        &sockopt, sizeof(sockopt)) == -1)
    logutil_warning("SO_REUSEADDR: %d", errno);
  if (bind(sock, (struct sockaddr *)&self_addr, self_addr_size) < 0)
    logutil_fatal("bind accepting socket: %d", errno);
  if (listen(sock, LISTEN_BACKLOG) < 0)
    logutil_fatal("listen: %d", errno);
  return (sock);
}

void
usage(void)
{
  fprintf(stderr, "Usage: %s [option]\n", program_name);
  fprintf(stderr, "option:\n");
  fprintf(stderr, "\t-d\t\t\t\t... debug mode\n");
  fprintf(stderr, "\t-p <port>\n");
  exit(1);
}

void
respond (void *_sock) {
  char c;
  FILE *fp;
  int sock = (int)_sock;

  send(sock, "HELLO. what you type will be echo back to you.\n", 47, 0);

  fp = fdopen(sock, "rb");
  while ((c = getc(fp)) != EOF) {
    send(sock, &c, 1, 0);
    fprintf(stderr, "%c", c);
  }

  send(sock, "disconnected\n", 13, 0);
  close(sock);
  fprintf(stderr, "socket [%d] disconnected.\n", sock);
}

void
main_loop (int sock) {
  struct sockaddr_in client_addr;
  int length;
  int client_sock;
  pthread_t responder;
  int i, j, cnt;

  for (cnt = 0;;cnt++) {
    length = sizeof(client_addr);
    client_sock = accept(sock, (struct sockaddr *)&client_addr, &length);
    fprintf(stderr, "opened socket [%d].\n", client_sock);

    printf("accepted connection from %d, port=%d\n",
        inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));

    pthread_create(&responder, NULL, (void *)respond, (void *)client_sock);
    pthread_detach(responder);
  }
}

int
main(int argc, char **argv)
{
  char *port_number = NULL;
  int ch, sock, server_port = DEFAULT_SERVER_PORT;
  int debug_mode = 0;

  while ((ch = getopt(argc, argv, "dp:")) != -1) {
    switch (ch) {
      case 'd':
        debug_mode = 1;
        break;
      case 'p':
        port_number = optarg;
        break;
      case '?':
      default:
        usage();
    }
  }
  argc -= optind;
  argv += optind;

  if (port_number != NULL)
    server_port = strtol(port_number, NULL, 0);

  /* server_portでlistenし，socket descriptorをsockに代入 */
  sock = open_accepting_socket(server_port);

  if (!debug_mode) {
    logutil_syslog_open(program_name, LOG_PID, LOG_LOCAL0);
    daemon(0, 0);
  }

  /*
   * 無限ループでsockをacceptし，acceptしたらそのクライアント用
   * のスレッドを作成しプロトコル処理を続ける．
   */
  main_loop(sock);

  /*NOTREACHED*/
  return (0);
}


実行手順
サーバを起動し、3つのクライアントから接続を試みる。

1. サーバを 3000 番ポートでデバッグモードで起動する。
2. クライアント 1 から接続し、文字列を入力する。
3. クライアント 2 から接続し、文字列を入力する。
4. クライアント 3 から接続し、文字列を入力する。
5. クライアント 3 から EOF を送信する。
6. クライアント 2 から EOF を送信する。
7. サーバを Ctrl+c で終了する。


実行結果
# サーバプログラムのコンソール
$ ./a.out -d -p 3000
opened socket [4].
accepted connection from -1218693472, port=58492
hello from client 1
opened socket [5].
accepted connection from -1218693472, port=58493
hello from client 2
opened socket [6].
accepted connection from -1218693472, port=58494
hello from client 3
socket [6] disconnected.
socket [5] disconnected.
^C

# クライアント 1 のコンソール
$ telnet localhost 3000
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
HELLO. what you type will be echo back to you.
hello from client 1
hello from client 1
Connection closed by foreign host.

# クライアント 2 のコンソール
6$ telnet localhost 3000
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
HELLO. what you type will be echo back to you.
hello from client 2
hello from client 2
^]

telnet> send EOF
disconnected
Connection closed by foreign host.

# クライアント 2 のコンソール
$ telnet localhost 3000
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
HELLO. what you type will be echo back to you.
hello from client 3
hello from client 3
^]

telnet> send EOF
disconnected
Connection closed by foreign host.


考察
複数のクライアントへのサービスを同時に行うことができている。
サーバ側の出力には、クライアントから送信された文字列が操作と同じ順で出力されていることが分かる。
クライアントから EOF を入力すると、各スレッドはコネクションを切断して正しく終了している。
また、サーバ自体がシャットダウンされた場合は、接続中のクライアントは即座に切断される。





演習問題 2
上記のプログラムにおいて，SIGINTとSIGTERMのシグナル処理を行うため のスレッドを生成し，シグナルが送信されたら bye と出力して終了するようにすること． 出力先は EOF を受け取った場合と同様とすること． サーバを Ctrl-C あるいは kill -TERM で落とした場合に bye が表示されるか確認しなさい． 


